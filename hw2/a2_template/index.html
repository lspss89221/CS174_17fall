<!-- Graphics Example Code.  index.html - The web page document containing the canvas (drawing surface), that launches your javascript files.  By Garett //-->
<!DOCTYPE html> <html> <head> <meta charset="UTF-8"/> <link rel="icon" href="assets/fav.ico">
<script type="text/javascript" src="tinywebgl-ucla.js" ></script>  <!--  Javascript "include" files.  Any code in them gets executed as part of the page loading. //-->
<script type="text/javascript" src="dependencies.js"   ></script>
<script type="text/javascript"> "use strict"    
  window.onload = function init()        // ********************* THE ENTRY POINT OF THE WHOLE PROGRAM STARTS HERE ********************* 
    { window.contexts = {};                                                            // A global variable, "contexts".  Browsers support up to 16 WebGL contexts per page.
      
      const scenes  = [ "Tutorial_Animation", "Movement_Controls", "Global_Info_Table" ]; // Register some scenes to the "Canvas_Manager" object -- which WebGL calls
                                                                                       // upon every time a draw / keyboard / mouse event happens.  
      
      if( eval( "typeof " + scenes[0] ) !== "undefined" )
      { document.getElementById( "canvases" ).appendChild( Object.assign( document.createElement( "canvas" ), { id: "main_canvas", width: 800, height: 600 } ) );
        contexts[ "main_canvas" ] = new Canvas_Manager( "main_canvas", Color.of( 0,0,0,1 ), scenes );   // Manage the WebGL canvas.  Second parameter sets background color.
        for( let c in contexts ) contexts[ c ].render();     // Call render() for each WebGL context on this page.  Then render() will re-queue itself for more calls.
        
        Code_Manager.display_code( eval( scenes[0] ) );                                  // Display the code for our demo on the page, starting with the first scene in the list.
        for( let list of [ core_dependencies, all_dependencies ] )
        document.querySelector( "#class_list" ).rows[2].appendChild( Object.assign( document.createElement( "td" ), { 
          innerHTML: list.reduce( (acc, x) => acc += "<a href='javascript:void(0);' onclick='Code_Manager.display_code(" + x + ")'>" + x + "</a><br>", "" ) } ) );        
        document.getElementsByName( "main_demo_link" )[0].innerHTML = "<a href='javascript:void(0);' onclick='Code_Manager.display_code(" + scenes[0] + ")'>" + scenes[0] + "</a><br>";
        document.querySelector("#code_display").innerHTML = "Below is the code for the demo that's running:<br>&nbsp;<br>" + document.querySelector("#code_display").innerHTML;             
      }
      
      document.querySelector("#edit_button").addEventListener('click', () => {
        code_panel.style.display=class_list.style.display='none'; new_demo_source_code.style.display='block'; 
        document.getElementsByName( 'new_demo_code' )[0].value=code_display.dataset.displayed.toString() } )
      const form = document.forms.namedItem("new_demo_source_code");
      form.addEventListener('submit', function(event) 
        { if( document.getElementsByName( "finished" )[0].checked )
            alert( "Your demo will be submitted.  If approved, you will start being asked for a password to make any further updates to it.  This password "
                 + "will appear right now, below the submit button, and then (assuming submission worked) it will never appear again.  Write it down." );
          var xhr = new XMLHttpRequest();
          xhr.open("POST", "/submit-demo?Unapproved", true);
          xhr.responseType = "json";
          xhr.onload = function(event) 
          { if (xhr.status != 200) { document.querySelector("#submit_result").textContent = "Error " + xhr.status + " when trying to upload."; return }
            document.querySelector("#submit_result").textContent = this.response.message;
            // if( this.response.hide_finished_checkbox ) { document.getElementsByName( "finished" )[0].checked = false; expert_panel.style.display = "none" }
            if( this.response.show_password  ) document.getElementsByName( "password" )[0] .style.display = "inline";
            if( this.response.show_overwrite ) document.querySelector( "#overwrite_panel" ).style.display = "inline";
          };
          xhr.setRequestHeader("Content-Type", "application/json");
          xhr.send( JSON.stringify( Array.from( form.elements ).reduce( ( accum, elem ) => 
            { if( elem.value && !( ['checkbox', 'radio'].includes(elem.type) && !elem.checked ) ) accum[elem.name] = elem.value; return accum }, {} ) ) );
          event.preventDefault();
        }, false);      
    }

// Below is the demo you will see when you run the program!    
// An example of a Scene_Component that our class Canvas_Manager can manage.  Like most, this one draws 3D shapes.

class Tutorial_Animation extends Scene_Component  
{ constructor( context )
    { super( context );
      var shapes = { 'trape' : new Trapezoid(),
                     'sphere' : new Subdivision_Sphere( 4 ),  
                     'box'   : new Cube(),
                     'triangle'        : new Triangle(), 
                                 // At the beginning of our program, instantiate all shapes we plan to use,
                     'strip'           : new Square(),                              // each with only one instance in the graphics card's memory.
                     'bad_tetrahedron' : new Tetrahedron( false ),                  // For example we would only create one "cube" blueprint in the GPU, but then 
                     'tetrahedron'     : new Tetrahedron( true ),                   // re-use it many times per call to display to get multiple cubes in the scene.
                     'windmill'        : new Windmill( 10 ),
                     'body': new Body(),
                     'prism': new ( Capped_Cylinder.prototype.make_flat_shaded_version() )( 10, 10, [[0,1],[0,1]] ),
                     'cylinder'        : new Cylinder( 10 )  };
      this.submit_shapes( context, shapes );
      
       // Place the camera, which is stored in a scratchpad for globals.  Secondly, setup the projection:  The matrix that determines how depth is treated.  It projects 3D points onto a plane.
      
      // Object.assign( context.globals.graphics_state, { camera_transform: Mat4.translation([ 0, 0,-25 ]), projection_transform: Mat4.perspective( Math.PI/4, context.width/context.height, .1, 1000 ) } );
      
      Object.assign( context.globals.graphics_state, { camera_transform: Mat4.translation([ 0, -200 ,320 ]), projection_transform: Mat4.perspective( Math.PI/4, context.width/context.height, .1, 1000 ) } );
      
      // *** Materials: *** Declare new ones as temps when needed; they're just cheap wrappers for some numbers.  1st parameter:  Color (4 floats in RGBA format),
      // 2nd: Ambient light, 3rd: Diffuse reflectivity, 4th: Specular reflectivity, 5th: Smoothness exponent, 6th: Optional texture object, leave off for un-textured.
      Object.assign( this, { 
                             purplePlastic: context.get_instance( Phong_Model  ).material( Color.of( .9,.5,.9, 1 ), .4, .4, .8, 40 ),
                             greenPlastic: context.get_instance( Phong_Model  ).material( Color.of( 0.1,0.3,.6, 1 ), .4, .4, .8, 40 ) ,         

                             blackPlastic: context.get_instance( Phong_Model  ).material( Color.of( 0,0,0, 1 ), 1, 0, 0, 40, context.get_instance( "assets/blackPlastic.jpg" ) ),
                             blackPlastic2: context.get_instance( Phong_Model  ).material( Color.of( 0.1,0.1,0.1, 1 ), 1, 0, 0, 40, context.get_instance( "assets/blackPlastic2.jpg" ) ),
                             blackPlastic3: context.get_instance( Phong_Model  ).material( Color.of( 0.12,0.12,0.12, 1 ), 1, 0, 0, 40, context.get_instance( "assets/blackPlastic2.jpg" ) ),
                             blackPlastic4: context.get_instance( Phong_Model  ).material( Color.of( 0.05,0.05,0.05, 1 ), 1, 0, 0, 40, context.get_instance( "assets/blackPlastic2.jpg" ) ),
                             blackPlastic5: context.get_instance( Phong_Model  ).material( Color.of( 0.25,0.25,0.25, 1 ), 1, 0, 0, 40, context.get_instance( "assets/blackPlastic2.jpg" ) ),
                             
                             brick: context.get_instance( Phong_Model  ).material( Color.of( 0,0,0, 1 ), 1, 0, 0, 40, context.get_instance( "assets/brick.jpg" ) ),  
                             trump: context.get_instance( Phong_Model  ).material( Color.of( 0,0,0,1 ), 1, 0, 0, 40, context.get_instance( "assets/trump.jpg" ) ),    
                             cla: context.get_instance( Phong_Model  ).material( Color.of( 0,0,0,1 ), 1, 0, 0, 40, context.get_instance( "assets/cla.jpg" ) ),    
                             
                             suit: context.get_instance( Phong_Model  ).material( Color.of( 0,0,0,1 ), 1, 0, 0, 40, context.get_instance( "assets/suit.jpg" ) ), 
                             skin: context.get_instance( Phong_Model  ).material( Color.of( 0,0,0,1 ), 1, 0, 0, 40, context.get_instance( "assets/skin.jpg" ) ),  
                             blackMedal1: context.get_instance( Phong_Model  ).material( Color.of( 0,0,0, 1 ), 1, 0, 0, 40, context.get_instance( "assets/blackMedal1.jpg" ) ),  
                             redPlastic  : context.get_instance( Phong_Model  ).material( Color.of( 1,0,0, 1 ), 1, 0, 0, 20 ),
                             greyPlastic  : context.get_instance( Phong_Model  ).material( Color.of( .5,.5,.5, 1 ), .4, .8, .4, 20 ),
                             greyPlastic2  : context.get_instance( Phong_Model  ).material( Color.of( .1,.1,.1, 1 ), .4, .8, .4, 20 ),   // Smaller exponent means 
                             blueGlass    : context.get_instance( Phong_Model  ).material( Color.of( .5,.5, 1,.2 ), .4, .8, .4, 40 ),   // a bigger shiny spot.
                             fire         : context.get_instance( Funny_Shader ).material(),
                             stars        : context.get_instance( Phong_Model  ).material( Color.of( 0,0,1,0.1 ), 0.2, 0.2, 0.2, 5, context.get_instance( "assets/stars.png" ) ),      
                             sky: context.get_instance( Phong_Model  ).material( Color.of( 0,0,0,1 ), 1, 0, 0, 40, context.get_instance( "assets/sky.jpg" ) ),    
                             desertTexture: context.get_instance( Phong_Model  ).material( Color.of( 0,0,0,1 ), 1, 0, 0, 40, context.get_instance( "assets/desertTexture.jpg" ) ),         
                             desertScene: context.get_instance( Phong_Model  ).material( Color.of( 0,0,0,1 ), 1, 0, 0, 40, context.get_instance( "assets/desertScene.jpg" ) ) } );         
                                                                         
    }
  
    
  drawGround(graphics_state, model_transform ){
    var ground = Mat4.identity()
    let mapsize = 500
    ground.post_multiply( Mat4.translation([ 0, 0, 0 ]) ); 
    ground.post_multiply( Mat4.scale([mapsize,mapsize,mapsize]))
    ground.post_multiply( Mat4.rotation(1/2*Math.PI,Vec.of(1,0,0)))
    this.shapes.strip.draw(graphics_state, ground, this.desertTexture) 

    var sky = Mat4.identity()
    sky.post_multiply( Mat4.translation([ 0, mapsize, 0 ]) ); 
    sky.post_multiply( Mat4.scale([mapsize,mapsize,mapsize]))
    sky.post_multiply( Mat4.rotation(1/2*Math.PI,Vec.of(1,0,0)))
    this.shapes.strip.draw(graphics_state, sky, this.sky) 

  }

  drawScene(graphics_state){
    var scene = Mat4.identity()
    let mapsize = 500
    for( let side of [-mapsize, mapsize]){
      scene = Mat4.identity()
      scene.post_multiply( Mat4.translation([ side, 0, 0 ]) ); 
      scene.post_multiply( Mat4.scale([mapsize,mapsize,mapsize]))
      scene.post_multiply( Mat4.rotation(1/2*Math.PI,Vec.of(0,1,0)))
      this.shapes.strip.draw(graphics_state, scene, this.sky)  
      
      scene = Mat4.identity()
      scene.post_multiply( Mat4.translation([ 0, 0, side ]) ); 
      scene.post_multiply( Mat4.scale([mapsize,mapsize,mapsize]))
      this.shapes.strip.draw(graphics_state, scene, this.sky)
    }

    for( let side of [-1, 1]){
      var particle = Mat4.identity()
      particle = particle.times(Mat4.translation([ side*32, 12, 0 ]))
      for( let i=0; i<8;i++ ){
          particle = particle.times(Mat4.translation([ 0, 0, -32 ]))
          this.shapes.box.draw(graphics_state, particle.times(Mat4.scale([ 16, 24, 16 ])), this.brick)
        }
    }
    for( let side of [-1, 1]){
      var particle = Mat4.identity()
      particle = particle.times(Mat4.translation([ -side*32, 12, -368 ]))
      for( let i=0; i<11;i++ ){
        particle = particle.times(Mat4.translation([ side*32, 0, 0]))
        this.shapes.box.draw(graphics_state, particle.times(Mat4.scale([ 16, 24, 16 ])), this.brick)
      }
      var particle = Mat4.identity()
      particle = particle.times(Mat4.translation([ 0, 12, -288 ]))
      for( let i=0; i<10;i++ ){
        particle = particle.times(Mat4.translation([ side*32, 0, 0]))
        this.shapes.box.draw(graphics_state, particle.times(Mat4.scale([ 16, 24, 16 ])), this.brick)
      }
    }

    for( let side of [-1, 1]){
      var particle = Mat4.identity()
      particle = particle.times(Mat4.translation([ -side*320, 12, -328 ]))
      this.shapes.box.draw(graphics_state, particle.times(Mat4.scale([ 16, 24, 24 ])), this.brick)  
    }

  }

  controlCamera(graphics_state){
    var t = graphics_state.animation_time/1000  
    if(t<10)
      graphics_state.camera_transform = Mat4.look_at( Vec.of( 0,30,-145 ), Vec.of( 0,22,-200 ), Vec.of( 0,1,0 ) );
    else if(t>=10 && t<20){
      var tt = t-10;
      graphics_state.camera_transform = Mat4.look_at( Vec.of( 0,20+5,4-16*tt ), Vec.of( 5*Math.sin(5*tt),20,-10000 ), Vec.of( 0,1,0 ) );
    }
    else if(t>=20 && t<25)
      graphics_state.camera_transform = Mat4.look_at( Vec.of( 0,20+5,4-160 ), Vec.of( 0,20,-10000 ), Vec.of( 0,1,0 ) );
    else if(t>=25 && t<30)
      graphics_state.camera_transform = Mat4.look_at( Vec.of( 0,20+5,4-160 ), Vec.of( 0,20,-10000 ), Vec.of( 0,1,0 ) );
    else if(t>=30 && t<35)
      graphics_state.camera_transform = Mat4.look_at( Vec.of( 0,20+5,4-160 ), Vec.of( 0,20,-10000 ), Vec.of( 0,1,0 ) );
    else if(t>=35 && t<45)
      graphics_state.camera_transform = Mat4.look_at( Vec.of( 0,20+5,4-160-16*(t-35) ), Vec.of( 0,20,-10000 ), Vec.of( 0,1,0 ) );
    else if(t>=45 && t<50){
      var tt = (t-45)/5
      graphics_state.camera_transform = Mat4.look_at( Vec.of( 4*Math.sin(tt*0.5*Math.PI)+0,20+5,4*Math.cos(tt*0.5*Math.PI)-320 ), Vec.of( -10000*Math.sin(tt*0.5*Math.PI),20,-320-10000*Math.cos(tt*0.5*Math.PI) ), Vec.of( 0,1,0 ) );
    }
    else if(t>=50 && t<55){
      graphics_state.camera_transform = Mat4.look_at( Vec.of( -230, 30 ,-328 ), Vec.of( -300, 20 ,-328 ), Vec.of( 0,1,0 ) );
    }
    else if(t>=55 && t<65){
      var tt = (t-55)/5
      graphics_state.camera_transform = Mat4.look_at( Vec.of( 4+0,20+5,-320 ), Vec.of( -10000,20,-320 ), Vec.of( 0,1,0 ) );
    }
    else if(t>=65 && t<70){
      var tt = (t-65)/5
      graphics_state.camera_transform = Mat4.look_at( Vec.of( 4*Math.cos(tt*Math.PI)+0,20+5,4*Math.sin(tt*Math.PI)-320 ), Vec.of( -10000*Math.cos(tt*Math.PI),20,-320-10000*Math.sin(tt*Math.PI) ), Vec.of( 0,1,0 ) );
    }
    else if(t>=70 && t<75){
      graphics_state.camera_transform = Mat4.look_at( Vec.of( 230, 30 ,-328 ), Vec.of( 300, 20 ,-328 ), Vec.of( 0,1,0 ) );
    }

    else if(t>=75 && t<100){
      var tt = (t-75)/5
      graphics_state.camera_transform = Mat4.look_at( Vec.of( -4+0,20+5,-320 ), Vec.of( 10000,20,-320) , Vec.of( 0,1,0 ) );
    }
    else if(t>100)
      graphics_state.camera_transform = Mat4.look_at( Vec.of( 0,0,0 ), Vec.of( 0,100,0) , Vec.of( 1,0,0 ) );
      
  }

  drawEnemy1(graphics_state, model_transform){
    var t = graphics_state.animation_time/1000
    var torso = model_transform.times(Mat4.translation( Vec.of( 0,0,0 ) ))
    var hp_grey = model_transform
    var hp_red = model_transform
    if(t<55){
      torso = torso.times(Mat4.translation( Vec.of( -280,20,-328 ) ))
      torso = torso.times(Mat4.rotation(0.5*Math.PI, Vec.of(0, 1, 0)))

      hp_grey = torso.times(Mat4.translation( Vec.of( 0,15,0 ) ))
      this.shapes.box.draw(graphics_state, hp_grey.times(Mat4.scale([6,1,1])), this.greyPlastic2)
      hp_red = torso.times(Mat4.translation( Vec.of( 0,15,0 ) ))
      this.shapes.box.draw(graphics_state, hp_red.times(Mat4.scale([6,1.1,1.1])), this.redPlastic)
    }
    else if(t>=55 && t<61){
      var tt = t-55
      torso = torso.times(Mat4.translation( Vec.of( -280+tt*(200/6),20,-328 ) ))
      torso = torso.times(Mat4.rotation(0.5*Math.PI, Vec.of(0, 1, 0)))
      hp_grey = torso.times(Mat4.translation( Vec.of( 0,15,0 ) ))
      this.shapes.box.draw(graphics_state, hp_grey.times(Mat4.scale([6,1,1])), this.greyPlastic2)

      hp_red = torso.times(Mat4.translation( Vec.of( -tt,15,0 ) ))
      this.shapes.box.draw(graphics_state, hp_red.times(Mat4.scale([6-tt,1.1,1.1])), this.redPlastic)
    }
    else if(t>=61){
      var tt = t-61
      torso = torso.times(Mat4.translation( Vec.of( -80-30*tt,20+30*tt,-328 ) ))
      torso = torso.times(Mat4.rotation(Math.cos(50*tt)*Math.PI, Vec.of(1, 0, 1)))
      torso = torso.times(Mat4.rotation(0.5*Math.PI, Vec.of(0, 1, 0)))
    }

    var body = torso.times(Mat4.translation( Vec.of( 0,-1.5,0 ) ))
    body = body.times(Mat4.scale([2,4,1]))
    body = body.times(Mat4.rotation(0.25*Math.PI,Vec.of( 0,1,0 )))
    this.shapes.body.draw(graphics_state, body.times(Mat4.scale([1,1.5,1])), this.purplePlastic)
    
    var neck = torso.times(Mat4.translation(Vec.of(0,4.5+0.5,0)))
    neck = neck.times(Mat4.rotation(0.1*Math.PI*Math.sin(5*t),Vec.of( 0,0,1 )))
    this.shapes.sphere.draw(graphics_state, neck.times(Mat4.scale([0.5,0.5,0.5])), this.skin)

    var head = neck.times(Mat4.translation(Vec.of(0,2+0.5,0)))
    this.shapes.box.draw(graphics_state, head.times(Mat4.scale([2,2,2])), this.trump)
    

    //shoulder position and angle
    for(let side of [1, -1]){
      var shoulder = torso.times(Mat4.translation( Vec.of( side*(2+5/3),3,0 ) ))
      
      if(t>=53){
        shoulder = shoulder.times(Mat4.rotation(side*0.3*Math.PI,Vec.of( 0,0,1 )))
        shoulder = shoulder.times(Mat4.rotation(side*0.4*Math.PI*Math.sin(5*t),Vec.of( 1,0,0 )))
      }
      this.shapes.sphere.draw(graphics_state, shoulder.times(Mat4.scale([1,1,1])), this.purplePlastic)
      

      var arm1 = shoulder.times(Mat4.translation( Vec.of( 0,-(1+1.8),0 ) ))
      this.shapes.sphere.draw(graphics_state, arm1.times(Mat4.scale([0.6,1.8,0.6])), this.purplePlastic)
      var elbow = arm1.times(Mat4.translation( Vec.of( 0,-(1.8+0.3),0 ) ))
      if(t>=53)
        elbow = elbow.times(Mat4.rotation(-0.5*Math.PI,Vec.of( 1,0,0 )))

      this.shapes.sphere.draw(graphics_state, elbow.times(Mat4.scale([0.3,0.3,0.3])), this.purplePlastic)
      
      var arm2 = elbow.times(Mat4.translation( Vec.of( 0,-(0.3+2),0 ) ))
      this.shapes.sphere.draw(graphics_state, arm2.times(Mat4.scale([0.4,2,0.4])), this.purplePlastic)

      var hand =arm2
      hand = hand.times(Mat4.translation( Vec.of( 0,-(2+0.4),0 ) ))
      this.shapes.sphere.draw(graphics_state, hand.times(Mat4.scale([0.4,0.4,0.4])), this.skin)
      
      for(let i of [+1, -1]){
        for(let j of [+1, -1]){
          var finger1 = hand.times(Mat4.rotation(0.25*Math.PI*Math.sin(5*t),Vec.of( i,0,j )))
          finger1 = finger1.times(Mat4.translation( Vec.of( 0,-(0.4+0.4),0 ) ))
          this.shapes.box.draw(graphics_state, finger1.times(Mat4.scale([0.06,0.4,0.06])), this.skin)
        }
      }
      
    }

    for(let side of [1, -1]){
      var guyB = torso.times(Mat4.translation( Vec.of( side*1,-(7.5+0.4),0 ) ))
      
      if(t>=53){
        guyB = guyB.times(Mat4.rotation(side*0.05*Math.PI,Vec.of( 0,0,1 )))
        guyB = guyB.times(Mat4.rotation(side*0.2*Math.PI*Math.sin(5*t),Vec.of( 1,0,0 )))
      }

      this.shapes.sphere.draw(graphics_state, guyB.times(Mat4.scale([0.4,0.4,0.4])), this.purplePlastic)
      
      var leg1 = guyB.times(Mat4.translation( Vec.of( 0,-(0.4+2.2),0 ) ))
      this.shapes.sphere.draw(graphics_state, leg1.times(Mat4.scale([0.6,2.2,0.6])), this.purplePlastic)
      var elbow = leg1.times(Mat4.translation( Vec.of( 0,-(2.2+0.4),0 ) ))
      if(t>=53)
        elbow = elbow.times(Mat4.rotation(-side*0.2*Math.PI*Math.sin(5*t),Vec.of( 1,0,0 )))

      this.shapes.sphere.draw(graphics_state, elbow.times(Mat4.scale([0.4,0.4,0.4])), this.purplePlastic)
      
      var leg2 = elbow.times(Mat4.translation( Vec.of( 0,-(0.4+2.4),0 ) ))
      this.shapes.sphere.draw(graphics_state, leg2.times(Mat4.scale([0.6,2.4,0.6])), this.purplePlastic)

      var foot =leg2
      foot = foot.times(Mat4.translation( Vec.of( 0,-(2.4+0.4),0 ) ))
      this.shapes.sphere.draw(graphics_state, foot.times(Mat4.scale([0.4,0.4,0.4])), this.skin)
      
      for(let i of [+1, -1]){
        for(let j of [+1, -1]){
          var finger1 = foot.times(Mat4.rotation(0.25*Math.PI*Math.sin(5*t),Vec.of( i,0,j )))
          finger1 = finger1.times(Mat4.translation( Vec.of( 0,-(0.4+0.4),0 ) ))
          this.shapes.box.draw(graphics_state, finger1.times(Mat4.scale([0.06,0.4,0.06])), this.skin)
        }
      }
      
    }

  }

  drawEnemy2(graphics_state, model_transform){
    var t = graphics_state.animation_time/1000
    var torso = model_transform.times(Mat4.translation( Vec.of( 4,0,0 ) ))
    var hp_grey = model_transform
    var hp_red = model_transform
    if(t<75){
      torso = torso.times(Mat4.translation( Vec.of( 280,20,-328 ) ))
      torso = torso.times(Mat4.rotation(0.5*Math.PI, Vec.of(0, 1, 0)))

      hp_grey = torso.times(Mat4.translation( Vec.of( 0,15,0 ) ))
      this.shapes.box.draw(graphics_state, hp_grey.times(Mat4.scale([6,1,1])), this.greyPlastic2)
      hp_red = torso.times(Mat4.translation( Vec.of( 0,15,0 ) ))
      this.shapes.box.draw(graphics_state, hp_red.times(Mat4.scale([6,1.1,1.1])), this.redPlastic)
    }
    else if(t>=75 && t<81){
      var tt = t-75
      torso = torso.times(Mat4.translation( Vec.of( 280-tt*(200/6),20,-328 ) ))
      torso = torso.times(Mat4.rotation(0.5*Math.PI, Vec.of(0, 1, 0)))
      hp_grey = torso.times(Mat4.translation( Vec.of( 0,15,0 ) ))
      this.shapes.box.draw(graphics_state, hp_grey.times(Mat4.scale([6,1,1])), this.greyPlastic2)

      hp_red = torso.times(Mat4.translation( Vec.of( tt,15,0 ) ))
      this.shapes.box.draw(graphics_state, hp_red.times(Mat4.scale([6-tt,1.1,1.1])), this.redPlastic)
    }
    else if(t>=81){
      var tt = t-81
      torso = torso.times(Mat4.translation( Vec.of( 80+30*tt,20+45*tt,-328-30*tt ) ))
      torso = torso.times(Mat4.rotation(Math.cos(50*tt)*Math.PI, Vec.of(0, 1, 0)))
      torso = torso.times(Mat4.rotation(0.5*Math.PI, Vec.of(0, 1, 0)))
    }

    var body = torso.times(Mat4.translation( Vec.of( 0,-1.5,0 ) ))
    body = body.times(Mat4.scale([2,4,1]))
    body = body.times(Mat4.rotation(0.25*Math.PI,Vec.of( 0,1,0 )))
    this.shapes.body.draw(graphics_state, body.times(Mat4.scale([1,1.5,1])), this.greenPlastic)
    
    var neck = torso.times(Mat4.translation(Vec.of(0,4.5+0.5,0)))
    neck = neck.times(Mat4.rotation(0.1*Math.PI*Math.sin(5*t),Vec.of( 0,0,1 )))
    this.shapes.sphere.draw(graphics_state, neck.times(Mat4.scale([0.5,0.5,0.5])), this.skin)

    var head = neck.times(Mat4.translation(Vec.of(0,2+0.5,0)))
    this.shapes.box.draw(graphics_state, head.times(Mat4.scale([2,2,2])), this.cla)
    

    //shoulder position and angle
    for(let side of [1, -1]){
      var shoulder = torso.times(Mat4.translation( Vec.of( side*(2+5/3),3,0 ) ))
      
      if(t>=73){
        shoulder = shoulder.times(Mat4.rotation(side*0.3*Math.PI,Vec.of( 0,0,1 )))
        shoulder = shoulder.times(Mat4.rotation(side*0.4*Math.PI*Math.sin(5*t),Vec.of( 1,0,0 )))
      }
      this.shapes.sphere.draw(graphics_state, shoulder.times(Mat4.scale([1,1,1])), this.greenPlastic)
      

      var arm1 = shoulder.times(Mat4.translation( Vec.of( 0,-(1+1.8),0 ) ))
      this.shapes.sphere.draw(graphics_state, arm1.times(Mat4.scale([0.6,1.8,0.6])), this.greenPlastic)
      var elbow = arm1.times(Mat4.translation( Vec.of( 0,-(1.8+0.3),0 ) ))
      if(t>=73)
        elbow = elbow.times(Mat4.rotation(0.5*Math.PI,Vec.of( 1,0,0 )))

      this.shapes.sphere.draw(graphics_state, elbow.times(Mat4.scale([0.3,0.3,0.3])), this.greenPlastic)
      
      var arm2 = elbow.times(Mat4.translation( Vec.of( 0,-(0.3+2),0 ) ))
      this.shapes.sphere.draw(graphics_state, arm2.times(Mat4.scale([0.4,2,0.4])), this.greenPlastic)

      var hand =arm2
      hand = hand.times(Mat4.translation( Vec.of( 0,-(2+0.4),0 ) ))
      this.shapes.sphere.draw(graphics_state, hand.times(Mat4.scale([0.4,0.4,0.4])), this.skin)
      
      for(let i of [+1, -1]){
        for(let j of [+1, -1]){
          var finger1 = hand.times(Mat4.rotation(0.25*Math.PI*Math.sin(5*t),Vec.of( i,0,j )))
          finger1 = finger1.times(Mat4.translation( Vec.of( 0,-(0.4+0.4),0 ) ))
          this.shapes.box.draw(graphics_state, finger1.times(Mat4.scale([0.06,0.4,0.06])), this.skin)
        }
      }
      
    }

    for(let side of [1, -1]){
      var guyB = torso.times(Mat4.translation( Vec.of( side*1,-(7.5+0.4),0 ) ))
      
      if(t>=73){
        guyB = guyB.times(Mat4.rotation(side*0.05*Math.PI,Vec.of( 0,0,1 )))
        guyB = guyB.times(Mat4.rotation(side*0.2*Math.PI*Math.sin(5*t),Vec.of( 1,0,0 )))
      }

      this.shapes.sphere.draw(graphics_state, guyB.times(Mat4.scale([0.4,0.4,0.4])), this.greenPlastic)
      
      var leg1 = guyB.times(Mat4.translation( Vec.of( 0,-(0.4+2.2),0 ) ))
      this.shapes.sphere.draw(graphics_state, leg1.times(Mat4.scale([0.6,2.2,0.6])), this.greenPlastic)
      var elbow = leg1.times(Mat4.translation( Vec.of( 0,-(2.2+0.4),0 ) ))
      if(t>=73)
        elbow = elbow.times(Mat4.rotation(-side*0.2*Math.PI*Math.sin(5*t),Vec.of( 1,0,0 )))

      this.shapes.sphere.draw(graphics_state, elbow.times(Mat4.scale([0.4,0.4,0.4])), this.greenPlastic)
      
      var leg2 = elbow.times(Mat4.translation( Vec.of( 0,-(0.4+2.4),0 ) ))
      this.shapes.sphere.draw(graphics_state, leg2.times(Mat4.scale([0.6,2.4,0.6])), this.greenPlastic)

      var foot =leg2
      foot = foot.times(Mat4.translation( Vec.of( 0,-(2.4+0.4),0 ) ))
      this.shapes.sphere.draw(graphics_state, foot.times(Mat4.scale([0.4,0.4,0.4])), this.skin)
      
      for(let i of [+1, -1]){
        for(let j of [+1, -1]){
          var finger1 = foot.times(Mat4.rotation(0.25*Math.PI*Math.sin(5*t),Vec.of( i,0,j )))
          finger1 = finger1.times(Mat4.translation( Vec.of( 0,-(0.4+0.4),0 ) ))
          this.shapes.box.draw(graphics_state, finger1.times(Mat4.scale([0.06,0.4,0.06])), this.skin)
        }
      }
      
    }

  }

  drawBody(graphics_state, model_transform){
    var t = graphics_state.animation_time/1000
    var torso = model_transform
    if(t<10)
      torso = torso.times(Mat4.translation( Vec.of( 0,20,0 ) ))
    else if(t>=10 && t<20){
      var tt = t-10;
      torso = torso.times(Mat4.translation( Vec.of( 0,20,-16*tt ) ))
    }
    else if(t>=20 && t<25)
      torso = torso.times(Mat4.translation( Vec.of( 0,20,-160 ) ))
    else if(t>=25 && t<30)
      torso = torso.times(Mat4.translation( Vec.of( 0,20,-160 ) ))
    else if(t>=30 && t<35)
      torso = torso.times(Mat4.translation( Vec.of( 0,20,-160 ) ))
    else if(t>=35 && t<45)
      torso = torso.times(Mat4.translation( Vec.of( 0,20,-160-16*(t-35) ) ))
    else if(t>=45 && t<50){
      var tt = (t-45)/5
      torso = torso.times(Mat4.translation( Vec.of( 0,20,-320 ) ))
      torso = torso.times(Mat4.rotation(0.5*Math.PI*Math.sin(tt*0.5*Math.PI), Vec.of(0, 1, 0)))
    }
    else if(t>=50 && t<65){
      torso = torso.times(Mat4.translation( Vec.of( 0,20,-320 ) ))
      torso = torso.times(Mat4.rotation(0.5*Math.PI, Vec.of(0, 1, 0)))  
    }
    else if(t>=65 && t<70){
      var tt = (t-65)/5
      torso = torso.times(Mat4.translation( Vec.of( 0,20,-320 ) ))
      torso = torso.times(Mat4.rotation(0.5*Math.PI-1*Math.PI*Math.sin(tt*0.5*Math.PI), Vec.of(0, 1, 0)))
    }
    else if(t>=70){
      torso = torso.times(Mat4.translation( Vec.of( 0,20,-320 ) ))
      torso = torso.times(Mat4.rotation(-0.47*Math.PI, Vec.of(0, 1, 0)))
    }

    var body = torso.times(Mat4.scale([2,4,1]))
    body = body.times(Mat4.rotation(0.25*Math.PI,Vec.of( 0,1,0 )))

    this.drawWeapon(graphics_state, torso)
    
    //shoulder position and angle
    for(let side of [1, -1]){
      var shoulder = torso.times(Mat4.translation( Vec.of( side*(2+5/3),3,0 ) ))
      if(t>=10 && t<20){
        shoulder = shoulder.times(Mat4.rotation(side*0.3*Math.PI,Vec.of( 0,0,1 )))
        shoulder = shoulder.times(Mat4.rotation(side*0.4*Math.PI*Math.sin(5*t),Vec.of( 1,0,0 )))
      }
      else if(t>=20 && t<25){
        var tt = (t-20)/5
        if(side==-1){
          shoulder = shoulder
        }
        else if(side==1){
          shoulder = shoulder.times(Mat4.rotation(side*0.5*Math.PI*Math.sin(tt),Vec.of( 0,0,1 )))
          shoulder = shoulder.times(Mat4.rotation(side*0.7*Math.PI*Math.sin(tt),Vec.of( 1,0,0 )))  
        }
      }
      else if(t>=25 && t<30){
        //left 
        if(side==-1){
          shoulder = shoulder
        }
        else if(side==1){
          shoulder = shoulder.times(Mat4.rotation(side*0.5*Math.PI*Math.sin(1),Vec.of( 0,0,1 )))
          shoulder = shoulder.times(Mat4.rotation(side*0.7*Math.PI*Math.sin(1),Vec.of( 1,0,0 )))
          shoulder = shoulder.times(Mat4.rotation(side*0.05*Math.PI*Math.sin(t),Vec.of( 1,0,0 )))    
        }
      }  
      else if(t>=30){
        if(side==-1){
          shoulder = shoulder.times(Mat4.rotation(0.4*Math.PI*Math.sin(1),Vec.of( 1,0,0 )))  
          shoulder = shoulder.times(Mat4.rotation(0.25*Math.PI*Math.sin(1),Vec.of( 0,0,1 )))  
        }
      }  
      if(t<30)
        this.shapes.sphere.draw(graphics_state, shoulder, this.greyPlastic)
      var arm1 = shoulder.times(Mat4.translation( Vec.of( 0,-(1+1.8),0 ) ))
      this.shapes.sphere.draw(graphics_state, arm1.times(Mat4.scale([0.6,1.8,0.6])), this.greyPlastic)
      var elbow = arm1.times(Mat4.translation( Vec.of( 0,-(1.8+0.3),0 ) ))
      if(t<20)
        elbow = elbow.times(Mat4.rotation(0.5*Math.PI,Vec.of( 1,0,0 )))
      else if(t>=20 && t<25){
        var tt = (t-20)/5
        elbow = elbow.times(Mat4.rotation(0.5*Math.PI,Vec.of( 1,0,0 )))
        elbow = elbow.times(Mat4.rotation(0.6*Math.PI*Math.sin(-tt),Vec.of( 1,0,0 )))
      }
      else if(t>=25 && t<30){
        elbow = elbow.times(Mat4.rotation(0.5*Math.PI,Vec.of( 1,0,0 ))) 
        elbow = elbow.times(Mat4.rotation(0.6*Math.PI*Math.sin(-1),Vec.of( 1,0,0 )))
      }
      else if(t>=30){
        if(side==-1){
          elbow = elbow.times(Mat4.rotation(0.1*Math.PI,Vec.of( 1,0,0 )))
          elbow = elbow.times(Mat4.rotation(0.25*Math.PI,Vec.of( 0,1,0 )))
           
        }
      }
      this.shapes.sphere.draw(graphics_state, elbow.times(Mat4.scale([0.3,0.3,0.3])), this.greyPlastic)
      
      var arm2 = elbow.times(Mat4.translation( Vec.of( 0,-(0.3+2),0 ) ))
      this.shapes.sphere.draw(graphics_state, arm2.times(Mat4.scale([0.4,2,0.4])), this.greyPlastic)

      var hand =arm2
      if(t<30){
        hand = hand.times(Mat4.translation( Vec.of( 0,-(2+0.4),0 ) ))
        this.shapes.sphere.draw(graphics_state, hand.times(Mat4.scale([0.4,0.4,0.4])), this.greyPlastic)
      }
      else if(t>=30){
        if(side==-1){
          hand = hand.times(Mat4.translation( Vec.of( 0,-(2+0.4),0 ) ))
          this.shapes.sphere.draw(graphics_state, hand.times(Mat4.scale([0.4,0.4,0.4])), this.greyPlastic)
        }
      } 
      
      for(let i of [+1, -1]){
        for(let j of [+1, -1]){
          if(t<25){
            var finger1 = hand.times(Mat4.rotation(0.25*Math.PI,Vec.of( i,0,j )))
            finger1 = finger1.times(Mat4.translation( Vec.of( 0,-(0.4+0.4),0 ) ))
            this.shapes.box.draw(graphics_state, finger1.times(Mat4.scale([0.06,0.4,0.06])), this.greyPlastic)
          }
          else if(t>=25 && t<30){
            var finger1 = hand.times(Mat4.rotation(0.25*Math.PI*Math.sin(5*t),Vec.of( i,0,j )))
            finger1 = finger1.times(Mat4.translation( Vec.of( 0,-(0.4+0.4),0 ) ))
            this.shapes.box.draw(graphics_state, finger1.times(Mat4.scale([0.06,0.4,0.06])), this.greyPlastic)
          }
          else{
            var finger1 = hand.times(Mat4.rotation(0.25*Math.PI,Vec.of( i,0,j )))
            finger1 = finger1.times(Mat4.translation( Vec.of( 0,-(0.4+0.4),0 ) ))
            this.shapes.box.draw(graphics_state, finger1.times(Mat4.scale([0.06,0.4,0.06])), this.greyPlastic)  
          }
        }
      }
      
    }
  }

  shootEnemy(graphics_state, model_transform){
    var t = graphics_state.animation_time/1000
    var shooting_t = graphics_state.animation_time/100
    
    if( (t>=55 && t<61)){
      for(let i=0; i<10; i++){
        var bullet = model_transform
        if(t>=55 && t<57)
          bullet = bullet.times(Mat4.translation([0, 0, -16*i-100*(t-55)]))
        if(t>=57 && t<59)
          bullet = bullet.times(Mat4.translation([0, 0, -16*i-100*(t-57)]))
        if(t>=59 && t<61)
          bullet = bullet.times(Mat4.translation([0, 0, -16*i-100*(t-59)]))
        this.shapes.sphere.draw(graphics_state, bullet.times(Mat4.scale([0.2,0.2,0.3])), this.greyPlastic)
      }
    }

    if( (t>=75 && t<81)){
      for(let i=0; i<10; i++){
        var bullet = model_transform
        if(t>=75 && t<77)
          bullet = bullet.times(Mat4.translation([0, 0, -16*i-100*(t-75)]))
        if(t>=77 && t<79)
          bullet = bullet.times(Mat4.translation([0, 0, -16*i-100*(t-77)]))
        if(t>=79 && t<81)
          bullet = bullet.times(Mat4.translation([0, 0, -16*i-100*(t-79)]))
        this.shapes.sphere.draw(graphics_state, bullet.times(Mat4.scale([0.2,0.2,0.3])), this.greyPlastic)
      }
    }
  
  }

  drawWeapon(graphics_state, model_transform){
    var t = graphics_state.animation_time/1000
    var body1 = Mat4.identity()
    var torso = model_transform
    if(t<30){
      body1 = body1.times(Mat4.translation( Vec.of( 6,25,-185 ) ))
      body1 = body1.times(Mat4.rotation(0.5*Math.PI,Vec.of( 0,1,0 )))
    }
    else if(t>=30){
      body1 = torso.times(Mat4.translation( Vec.of( 3 ,3.5,-5 ) ))
      body1 = body1.times(Mat4.rotation(-0.01*Math.PI,Vec.of( 0,1,0 )))
    }    
    else if(t>=65){
      body1 = torso.times(Mat4.translation( Vec.of( 3 ,3.5,-5 ) ))
    }    

    this.shapes.box.draw(graphics_state, body1.times(Mat4.scale([0.4,0.6,2.4])), this.blackPlastic2)
    var body2 = body1.times(Mat4.translation( Vec.of( 0,-0.9,0 ) ))
    this.shapes.box.draw(graphics_state, body2.times(Mat4.scale([0.44,0.3,2])), this.blackPlastic2)
    
    var stock1 = body1.times(Mat4.translation( Vec.of( 0,0,3 ) ))
    this.shapes.box.draw(graphics_state, stock1.times(Mat4.scale([0.3,0.5,0.6])), this.blackPlastic5)

    var stock2 = body1.times(Mat4.translation( Vec.of( 0,-0.5,3+1.2+1 ) ))
    stock2 = stock2.times(Mat4.rotation(1/2*Math.PI,Vec.of(0,1,0)))
    stock2 = stock2.times(Mat4.rotation(3/2*Math.PI,Vec.of(0,0,1)))
    this.shapes.trape.draw(graphics_state, stock2.times(Mat4.scale([1,1.6,0.31])), this.blackPlastic5)

    var stock2 = body1.times(Mat4.translation( Vec.of( 0,-0.5,3+1.2+1+1.6+0.1 ) ))
    this.shapes.box.draw(graphics_state, stock2.times(Mat4.scale([0.3,1,0.1])), this.blackPlastic)

    var sightF1 = body1.times(Mat4.translation( Vec.of( 0,0.6+0.35,-2.4+0.3 ) ))
    this.shapes.box.draw(graphics_state, sightF1.times(Mat4.scale([0.2,0.35,0.1])), this.blackPlastic4)
    var sightF2 = body1.times(Mat4.translation( Vec.of( 0,0.6+0.4,2.4-1.8 ) ))
    this.shapes.box.draw(graphics_state, sightF2.times(Mat4.scale([0.2,0.4,0.1])), this.blackPlastic4)
    var sightT1 = body1.times(Mat4.translation( Vec.of( 0,0.6+0.6,-0.4 ) ))
    this.shapes.box.draw(graphics_state, sightT1.times(Mat4.scale([0.2,0.1,1.8])), this.blackPlastic4)
    var sightT2 = body1.times(Mat4.translation( Vec.of( 0,0.6+0.42,2.4-1.0 ) ))
    this.shapes.box.draw(graphics_state, sightT2.times(Mat4.scale([0.21,0.42,0.8])), this.blackPlastic4)
    var screwT2 = sightT2.times(Mat4.translation( Vec.of( 0,0,0.2 ) ))
    screwT2 = screwT2.times(Mat4.rotation(1/2*Math.PI,Vec.of(0,1,0)))
    this.shapes.prism.draw(graphics_state, screwT2.times(Mat4.scale([0.15,0.15,0.6])), this.blackMedal1)
    
    var gunGrip = body1.times(Mat4.translation( Vec.of( 0,-0.6-1,2.4-1.0 ) ))
    gunGrip = gunGrip.times(Mat4.rotation(3/2*Math.PI,Vec.of(0,1,0)))
    gunGrip = gunGrip.times(Mat4.rotation(1/12*Math.PI,Vec.of(0,0,1)))
    this.shapes.trape.draw(graphics_state, gunGrip.times(Mat4.scale([0.55,2,0.28])), this.blackPlastic2)

    var trigger1 = body1.times(Mat4.translation( Vec.of( 0,-0.6-0.7,0.3 ) ))
    trigger1 = trigger1.times(Mat4.rotation(1/3*Math.PI,Vec.of(1,0,0)))
    this.shapes.box.draw(graphics_state, trigger1.times(Mat4.scale([0.15,0.05,0.2])), this.blackPlastic4)    

    var trigger2 = body1.times(Mat4.translation( Vec.of( 0,-0.6-1,0 ) ))
    trigger2 = trigger2.times(Mat4.rotation(1/36*Math.PI,Vec.of(1,0,0)))
    this.shapes.box.draw(graphics_state, trigger2.times(Mat4.scale([0.18,0.05,1])), this.blackPlastic4)
    
    var mag = body1.times(Mat4.translation( Vec.of( 0,-0.6-0.5,-2.4+1.4 ) ))
    mag = mag.times(Mat4.rotation(3/2*Math.PI,Vec.of(0,1,0)))
    mag = mag.times(Mat4.rotation(-1/24*Math.PI,Vec.of(0,0,1)))
    mag = mag.times(Mat4.rotation(Math.PI,Vec.of(0,1,0)))
    this.shapes.box.draw(graphics_state, mag.times(Mat4.scale([0.7,0.6,0.28])), this.blackPlastic2)

    var mag2 = mag.times(Mat4.translation( Vec.of( 0,-0.6-1.2,0 ) ))
    mag2 = mag2.times(Mat4.rotation(1/24*Math.PI,Vec.of(0,0,1)))
    mag2 = mag2.times(Mat4.translation( Vec.of( 0.15,0.1,0 ) ))
    this.shapes.box.draw(graphics_state, mag2.times(Mat4.scale([0.6,1.2,0.25])), this.blackPlastic3)

    var barrel0 = body1.times(Mat4.translation( Vec.of( 0,0,-2.9 ) ))
    this.shapes.prism.draw(graphics_state, barrel0.times(Mat4.scale([0.5,0.5,1])), this.greyPlastic)

    var barrel1 = barrel0.times(Mat4.translation( Vec.of( 0,0,-5 ) ))
    this.shapes.prism.draw(graphics_state, barrel1.times(Mat4.scale([0.6,0.6,10])), this.blackPlastic)

    var scope1 = barrel1.times(Mat4.translation( Vec.of( 0,0.8,-5.1 ) ))
    this.shapes.box.draw(graphics_state, scope1.times(Mat4.scale([0.2,0.75,0.03])), this.greyPlastic)   

    var barrel2 = barrel1.times(Mat4.translation( Vec.of( 0,0,-7.5 ) ))
    this.shapes.prism.draw(graphics_state, barrel2.times(Mat4.scale([0.25,0.25,5])), this.greyPlastic)   

    var compensator = barrel2.times(Mat4.translation( Vec.of( 0,0,-3 ) ))
    this.shapes.prism.draw(graphics_state, compensator.times(Mat4.scale([0.35,0.35,2])), this.greyPlastic) 

    if(t<30){
      var circle = body1.times(Mat4.translation( Vec.of( 0,0,-5 ) ))
      this.shapes.sphere.draw(graphics_state, circle.times(Mat4.scale([14.5,14.5,14.5])), this.stars)
    }
    this.shootEnemy(graphics_state, compensator)   
  }

  display( graphics_state )
    { var model_transform = Mat4.identity();             // We begin with a brand new model_transform every frame.
      
      // *** Lights: *** Values of vector or point lights over time.  Two different lights *per shape* supported by Phong_Shader; more requires changing a number in the vertex 
      graphics_state.lights = [ new Light( Vec.of(  30,  30,  34, 1 ), Color.of( 0, .4, 0, 1 ), 100000 ),      // shader.  Arguments to construct a Light(): Light source position
                                new Light( Vec.of( -10, -20, -14, 0 ), Color.of( 1, 1, .3, 1 ), 100    ) ];    // or vector (homogeneous coordinates), color, and size.  
      this.controlCamera(graphics_state)
      var t = graphics_state.animation_time/1000
      
      // if(t<1)
      //   graphics_state.camera_transform = Mat4.look_at( Vec.of( 0,30,-145 ), Vec.of( 0,22,-200 ), Vec.of( 0,1,0 ) );
    
      this.drawGround(graphics_state)
      this.drawScene(graphics_state)
      this.drawBody(graphics_state, model_transform)
      this.drawEnemy1(graphics_state, model_transform)
      this.drawEnemy2(graphics_state, model_transform)
      
      
      var tilt_spin   = Mat4.rotation( 12*t, Vec.of(          .1,          .8,             .1 ) )
      var funny_orbit = Mat4.rotation(  2*t, Vec.of( Math.cos(t), Math.sin(t), .7*Math.cos(t) ) );

      // Many shapes can share influence of the same pair of lights, but they don't have to.  All the following shapes will use these lights instead of the above ones.
      graphics_state.lights = [ new Light( tilt_spin.times( Vec.of(  30,  30,  34, 1 ) ), Color.of( 0, .4, 0, 1 ), 100000               ),
                                new Light( tilt_spin.times( Vec.of( -10, -20, -14, 0 ) ), Color.of( 1, 1, .3, 1 ), 100*Math.cos( t/10 ) ) ];
    }
}
</script>
<style>
  table { border-collapse: collapse; display:block; overflow-x: auto; }
  table, th, td { border: 2px solid black; vertical-align: top; white-space: nowrap }
  th, td { overflow: hidden;  }
  button { position: relative; background-color: #4C9F50; color: white; padding: 6px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); transition: background-color .3s, transform .3s }
  button:hover, button:focus { transform: scale(1.2); color:gold }
  .dropdown { display:inline-block }
  .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; min-width: 100px; overflow: auto; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2) }
  .dropdown-content a { color: black; padding: 4px 4px; display: block }
  .dropdown a:hover { background-color: #f1f1f1 }
  .show { display:inline-block }
</style>
</head><body>
<div id="explanation_section"></div>
<div id="canvases"></div>
<table id="control_buttons" class="dropdown" style="display:block; width: 70%;  border: 0px; margin: 0 0 50px 0"><tr></tr></table>
<div id="code_panel" style="font-family: monospace; white-space: pre; margin: 50px 0" >
  <div id="code_display"  data-displayed="" ></div>
  <button id="edit_button" style="display:none">Start editing</button> 
  <table id="class_list" class="dropdown" style="display:block; border: 0px; border-spacing: 10px " >
    <tr><td colspan="2">Click below to navigate through all classes that are defined. <br>&nbsp;<br>Main demo: <span name="main_demo_link"></span></td></tr>
    <tr style="text-align:center"><td>tinywebgl-ucla.js</td><td>dependencies.js</td></tr><tr></tr></table>
</div>
<form name="new_demo_source_code" style="display:none">  
  <p style="margin: 50px 0"><i><b>What can I put here?</b></i>  A JavaScript class, with any valid JavaScript inside.  Your code can use classes from this demo, or from ANY demo on the 
  encyclopedia of code --  the dependencies will automatically be pulled in to run your demo!<br></p>
  <textarea rows="30" cols="140" name="new_demo_code"></textarea><br>
  <div id="submit_result" style="margin: 10px 0"></div>
  <button type="submit" style="margin: 0px 50px 0px 0px">Save as new webpage</button> 
  <input type="text" name="author"   placeholder="Author name">
  <input type="text" name="password" placeholder="Password" style="display:none">
  <span id="overwrite_panel" style="display:none"><label>Overwrite?<input type="checkbox" name="overwrite" autocomplete="off"></label></span>
  <span id="beginner_panel"><label>Beginner Mode<input type="checkbox" checked onchange="document.querySelector('#expert_panel').style.display='block'; beginner_panel.style.display='none'"></label></span>
  <div id="expert_panel" style="display:none;"><label><input type="checkbox" name="finished" autocomplete="off">
    Optional:  This demo is finished; consider it for public listing on the main page.  
    I believe that this demo is the one true way to minimalistically do what its name says.
    The code's readability and structure are so good as to maximize how easy it is to memorize it.
    </label></div>  
</form>
</body></html>